## 事件流（捕获、冒泡）
事件流：指从页面中接收事件的顺序，有冒泡流和捕获流。
当页面中发生某种事件（比如鼠标点击，鼠标滑过等）时，毫无疑问子元素和父
元素都会接收到该事件，可具体顺序是怎样的呢？冒泡和捕获则描述了两种不同
的顺序。
	冒泡：从window到document-->body-->div（父元素到子元素）
	捕获：是冒泡的倒序
我们一般注册事件在冒泡阶段，为了兼容更多的浏览器

## 事件处理程序
1. DOM 0 级事件处理程序
	1 var btn5 = document.getElementById('btn5');
	2 btn5.onclick=function(){
	3    console.log(this.id);//btn5   
	4 };
基于DOM0的事件，对于同一个dom节点而言，只能注册一个，后边注册的 
同种事件 会覆盖之前注册的。利用这个原理我们可以解除事件，
btn5.onclick＝null;其中this就是绑定事件的那个元素；
 
以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理；

2. DOM 2 级事件处理程序
DOM2支持同一dom元素注册多个同种事件，事件发生的顺序按照添加的
顺序依次触发（IE是相反的）。
DOM2事件通过addEventListener和removeEventListener管理
//addEventListener(eventName,handlers,boolean);
removeEventListener(),两个方法都一样接收三个参数,
第一个是要处理的事件名,
第二个是事件处理程序,
第三个值为false时表示在事件冒泡阶段调用事件处理程序,
一般建议在冒泡阶段使用,特殊情况才在捕获阶段;
注意：通过addEventListener()添加的事件处理程序
只能用removeEventListener()来移除，并且移除时传入的参数必须与添加时传入的参数一样。

**IE事件处理程序**
IE用了attachEvent(),detachEvent(),接收两个参数,事件名称和事件处理程
序,通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段,所以平时为了兼容更多的浏览器最好将事件添加到事件冒泡阶段,IE8及以前只支持事件冒泡;
	1 var btn3 = document.getElementById('btn3');
	2 var handlers2=function(){
	3    console.log(this===window);//true,注意attachEvent()添加的事件处理程序运行在全局作用域中;
	4 };
	5 btn3.attachEvent('onclick',handlers2);

### 事件对象
兼容触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含了所
有与事件有关的信息，比如导致事件的元素target，事件的类型，及其他特定的
相关信息。例如鼠标操作导致的事件对象中会包含鼠标的位置，单双击等，而键盘
操作导致的事件对象会包含按下的键等信息；
 
事件被触发时，会默认给事件处理程序传入一个参数e , 
表示事件对象；通过e，我们可以获得其中包含的与事件有关的信息；
 
**事件对象存在的生命周期**
只有在事件处理程序执行期间，event对象才会存在，一旦事件处理程序执行完毕
，event对象就会被销毁；

event.stopPropagation()可以组织事件的传播，但它阻止不了绑定在该元素上的其他函数的执行，
event.stopImmediatePropagation()，那么第二个事件也会被阻止，它不仅阻止事件的传播还阻止后续事件的执行

### 事件委托
合理的利用冒泡，例如父元素和子元素都要执行相同的事件，那我们可以在父元素中
注册事件，它的触发将会导致父元素的事件触发。而我们只写了一个事件，这就是
事件委托。

**为什么要使用事件委托**
在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运
行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器
重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么
性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所
有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少
与dom的交互次数，提高性能。使用事件委托，**新增加的子元素也会自然的绑定事件。不需要我们去遍历元素的子节点。**
  
**判断哪一个元素正在执行事件**
 （事件对象）Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件
 源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作
 dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.
 srcElement。

**适合使用事件委托的事件**
 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。

值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候
需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。