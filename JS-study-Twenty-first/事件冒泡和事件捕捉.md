当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段 - 
捕获阶段和冒泡阶段。 在捕获阶段：

    -1.浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了
    一个onclick事件处理程序，如果是，则运行它。
    -2.然后，它移动到<html>中的下一个元素，并执行相同的操作，然后是下一个元素，
    依此类推，直到到达实际点击的元素。

在冒泡阶段，恰恰相反:

    -1.浏览器检查实际点击的元素是否在冒泡阶段中注册了一个onclick事件处理程序，如
    果是，则运行它
    -2.然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到
    它到达<html>元素。
冒泡触发，从内到外。
事件捕捉则是从外进到内。

## 阻止冒泡，用stopPropagation()修复问题

这是令人讨厌的行为，但有一种方法来解决它！标准事件对象具有可用的名为 
stopPropagation()的函数, 
当在事件对象上调用该函数时，它只会让当前事件处理程序运行，
但事件不会在冒泡链上进一步扩大，因此将不会有更多事件处理器被运行(不会向上冒泡)
。所以，我们可以通过改变前面代码块中的第二个处理函数来解决当前的问题:

	video.onclick = function(e) {
	  e.stopPropagation();
	  video.play();
	};
如果您真的想在捕获阶段注册一个事件，那么您可以通过使用addEventListener()注册您的
处理程序，并将可选的第三个属性设置为true。一般不在捕获阶段，所以设置的为false。

### 事件委托

冒泡还允许我们利用事件委托——这个概念依赖于这样一个事实,如果你想要在大量子元素中单
击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并将事件监听器
气泡的影响设置为每个子节点，而不是每个子节点单独设置事件监听器。

一个很好的例子是一系列列表项，如果你想让每个列表点击时弹出一条信息，您可以将click
单击事件监听器设置在父元素<ul>上，它将会冒泡到列表项上。